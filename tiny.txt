#define TINYOBJLOADER_IMPLEMENTATION
#include "tiny_obj_loader.h"

#include <iostream>
#include <vector>
#include <string>

struct Vertex {
    float x, y, z;
};

int main() {
    std::string inputfile = "models/model.obj"; // Change to your OBJ path

    tinyobj::attrib_t attrib;
    std::vector<tinyobj::shape_t> shapes;
    std::vector<tinyobj::material_t> materials;
    std::string warn, err;

    bool ret = tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, inputfile.c_str());

    if (!warn.empty()) {
        std::cout << "WARN: " << warn << std::endl;
    }
    if (!err.empty()) {
        std::cerr << "ERR: " << err << std::endl;
    }
    if (!ret) {
        std::cerr << "Failed to load OBJ file." << std::endl;
        return 1;
    }

    // Loop over shapes
    for (size_t s = 0; s < shapes.size(); s++) {
        std::cout << "Shape: " << shapes[s].name << std::endl;

        size_t index_offset = 0;
        for (size_t f = 0; f < shapes[s].mesh.num_face_vertices.size(); f++) {
            int fv = shapes[s].mesh.num_face_vertices[f]; // usually 3 for triangles

            std::cout << "  Face " << f << ": ";
            for (size_t v = 0; v < fv; v++) {
                // Access to vertex
                tinyobj::index_t idx = shapes[s].mesh.indices[index_offset + v];
                float vx = attrib.vertices[3 * idx.vertex_index + 0];
                float vy = attrib.vertices[3 * idx.vertex_index + 1];
                float vz = attrib.vertices[3 * idx.vertex_index + 2];
                std::cout << "(" << vx << ", " << vy << ", " << vz << ") ";
            }
            std::cout << std::endl;
            index_offset += fv;
        }
    }

    return 0;
}

